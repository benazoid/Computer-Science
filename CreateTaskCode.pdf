//Uses the p5.js library made by Stephen Fry and Casey Reas
//I used some code made by the YouTuber CodeTheBoat for the collision response
//Here's his video https://www.youtube.com/watch?v=_xj8FyG-aac&t=276s

let keys = [];
let Keys = {
  up: 32, //space
  down: 83, //s
  left: 65, //a
  right: 68, //d
  changeView: 80, //p
}
let respawn;
let player;
let grav = 0.2;
let boxes = [];
let area = [];
let camera;
let view = 1;
let obsticles = [];
let obArea = [];
let parts = [];
let words = [];
let checks = [];
let pressedKeys = [];
let flyMode = false;
let flyKeys = [72,73,84,72,69,82,69];

let curCheck = 0;

function findAng(x1,y1,x2,y2){
  let theta = (y2 >= y1) ? Math.atan((x2-x1)/(y2-y1))+(Math.PI) : Math.atan((x2-x1)/(y2-y1))+(2*Math.PI);
  return -theta;
}
function clamp(min,max,value){
  if(value < min){
    return min;
  }
  else if(value < max){
    return value;
  }
  else{
    return max;
  }
}
function rectCircle(rectX,rectY,rectW,rectH,circX,circY,circDia){
  let x = clamp(rectX,rectX+rectW,circX);
  let y = clamp(rectY,rectY+rectH,circY);
  if(dist(x,y,circX,circY) <= circDia/2){
    return true;
  }
  return false;
}
function getInd(list,find){
  for(let i = 0; i < list.length; i++){
    if(find === list[i]){
      return i;
    }
  }
  return false;
}

function keyPressed(){
  pressedKeys.push(keyCode);
  keys[keyCode] = true;
  if(keyCode == Keys.left || keyCode == Keys.right && !flyMode){
    player.vel.x = 3;
  }

  //Jump
  if(player.canJump && keyCode == Keys.up && player.jumpReset){
    player.vel.y = -player.jumpForce;
    if(!(player.boxGrounds.includes("left") || player.boxGrounds.includes("right"))){
      player.jumpAmount ++;
    }
    if(player.jumpAmount >= player.jumpTimes){
      player.jumpReset = false;
    }
    if(player.touchWall){
      player.changeBack = true;
    }


  }
}
function keyReleased(){
  keys[keyCode] = false;
  if(keyCode == Keys.left || keyCode == Keys.right){
    player.vel.x = 3;
  }
  if(keyCode == Keys.up){
    player.jumpStop = true;
  }
}

function drawBox(x,y,w,h,type){
  /*let big = Math.max(w,h);
  let sml = Math.min(w,h);
  let offX;
  let offY;
  if(big == w){
    offX = sml;
    offY = 0;
  }
  else{
    offX = 0;
    offY = sml;
  }
  rect(x,y,w,h);
  for(let i = 0; i < big; i+= sml){
    if(big == w){
      line(x+i,y,x+i+offX,y+sml);
      line(x+i+sml,y,x+i,y+sml);
    }
    if(big == h){
      line(x,y+i,x+sml,y+sml+i);
      line(x+sml,y+i,x,y+sml+i);
    }
  }*/

  if(type == "changePoint"){
    noStroke();
    fill(242, 255, 102);
    rect(x,y,w,h);
    fill(199, 209, 88);
    rect(x+3,y+3,w-6,h-6);
    fill(242, 255, 102);
    rect(x+6,y+6,w-12,h-12);
    fill(199, 209, 88);
    rect(x+8,y+8,7,3);
    rect(x+8,y+8,3,7);
    rect(x+w-16,y+8,7,3);
    rect(x+w-12,y+8,3,7);
    rect(x+w-16,y+h-11,7,3);
    rect(x+w-12,y+h-15,3,7);
    rect(x+8,y+h-11,7,3);
    rect(x+8,y+h-15,3,7);
    if(w > 100){
      for(let i = 50; i < w; i += 50){
        if(i < w - 30){
          rect(x+i,y+5,4,4);
          rect(x+i+4,y+8,4,4);
          rect(x+i-25,y+h-9,4,4);
          rect(x+i-29,y+h-12,4,4);
        }
      }
    }
    if(h > 100){
      for(let i = 50; i < h; i += 50){
        if(i < h - 30){
          rect(x+6,y+i,4,4);
          rect(x+9,y+i+4,4,4);
          rect(x+w-9,+y+i-25,4,4);
          rect(x+w-12,y+i-29,4,4);
        }
      }
    }
  }
  else{
    noStroke();
    fill(66, 245, 153);
    rect(x,y,w,h);
    fill(55, 179, 115);
    rect(x+3,y+3,w-6,h-6);
    fill(66, 245, 153);
    rect(x+6,y+6,w-12,h-12);
    fill(55, 179, 115);
    rect(x+8,y+8,7,3);
    rect(x+8,y+8,3,7);
    rect(x+w-16,y+8,7,3);
    rect(x+w-12,y+8,3,7);
    rect(x+w-16,y+h-11,7,3);
    rect(x+w-12,y+h-15,3,7);
    rect(x+8,y+h-11,7,3);
    rect(x+8,y+h-15,3,7);
    if(w > 100){
      for(let i = 50; i < w; i += 50){
        if(i < w - 30){
          rect(x+i,y+5,4,4);
          rect(x+i+4,y+8,4,4);
          rect(x+i-25,y+h-9,4,4);
          rect(x+i-29,y+h-12,4,4);
        }
      }
    }
    if(h > 100){
      for(let i = 50; i < h; i += 50){
        if(i < h - 30){
          rect(x+6,y+i,4,4);
          rect(x+9,y+i+4,4,4);
          rect(x+w-9,+y+i-25,4,4);
          rect(x+w-12,y+i-29,4,4);
        }
      }
    }
  }
}

class Particle{
  constructor(parent){
    this.parent = parent;
    this.x = parent.x;
    this.y = parent.y;
    this.dir = random(parent.startA,parent.endA) * PI/180;
    this.fade = 0;
  }
  show(){
    colorMode(RBGA);
    fill(this.parent.color,this.fade);
    noStroke();
    rect(this.x,this.y);
  }
  move(){
    this.x += cos(this.dir);
    this.y += sin(this.dir);
  }
}

class Particles{
  constructor(x,y,startA,endA,size,amount,color){
    this.x = x;
    this.y = y;
    //In degrees
    this.startA = startA;
    this.endA = endA;
    this.amt = intensity;
    this.col = color;
    this.index = parts.length - 1;
  }
  make(){

  }
}

class Obj{
  constructor(x,y,settings){
    this.x = x;
    this.y = y;
    this.set = settings;
    this.canMove = settings.move;
    this.start = new p5.Vector(x,y);
    this.end = new p5.Vector(settings.x2,settings.y2);
    this.speed = settings.speed;
    this.point = true;
    this.dir = this.findAng();
    this.box = [];
  }
  findAng(){
    let theta = (this.end.y >= this.start.y) ? Math.atan((this.end.x-this.start.x)/(this.end.y-this.start.y))+(1.5*Math.PI) : Math.atan((this.end.x-this.start.x)/(this.end.y-this.start.y))+(0.5*Math.PI);
    return -theta;
  }
  move(){
    if(this.canMove){
      if(this.point){
        this.x += cos(this.dir) * this.speed;
        this.y += sin(this.dir) * this.speed;
      }
      else{
        this.x -= cos(this.dir) * this.speed;
        this.y -= sin(this.dir) * this.speed;
      }

      let rectX = min(this.start.x,this.end.x);
      let rectY = min(this.start.y,this.end.y);
      let othX = max(this.start.x,this.end.x);
      let othY = max(this.start.y,this.end.y);
      this.box = [rectX,rectY,rectX-othX,rectY-othY];
      stroke(1);
      if(!(this.x >= rectX && this.y >= rectY && this.x <= othX && this.y <= othY)){
        this.point = !this.point;
      }
    }
  }
}

class Respawn{
  constructor(){
    this.x = -75;
    this.y = 384;
  }
  changePoint(x,y){
    curCheck = getInd(checks,this);
    this.x = x;
    this.y = y;
  }
  update(){
    let check = checks[curCheck];
  }
}

class Enemy extends Obj{
  constructor(x,y,width,height,settings){
    super(x,y,settings);
    this.w = width;
    this.h = height;
    this.type = settings.type;
    this.color = settings.color;
  }
  show(){
    stroke(1);
    fill(this.color);
    noStroke();
    rect(this.x+(width/2-camera.x) ,this.y+(height/2-camera.y),this.w,this.h);
  }
  collide(){
    if(collideRectCircle(this.x,this.y,this.w,this.h,player.x,player.y,player.dia)){
      player.dead = true;
      player.deadType = this.color;
    }
  }
}

class Box extends Obj{
  constructor(x,y,w,h,settings){
    super(x,y,settings);
    this.w = w;
    this.h = h;
    this.settings = settings;
    this.index = boxes.length;
    this.scaleX = 0;
    this.scaleY = 0;
    this.function = settings.function;
    if(settings.function == "changePoint"){
      checks.push(this);
    }
  }
  show(){
    drawBox(this.x+(width/2-camera.x) + this.scaleX ,this.y+(height/2-camera.y) + this.scaleY,this.w + this.scaleX,this.h + this.scaleY,this.function);
  }
  collide(i){
    let x = clamp(this.x,this.x+this.w,player.x);
    let y = clamp(this.y,this.y+this.h,player.y);
    if(player.x < this.x){
      x = this.x;
    }
    else if(player.x > this.x + this.w){
      x = this.x + this.w;
    }
    let theta = findAng(x,y,player.x,player.y);
    if(player.boxGrounds.length > area.length){
      player.boxGrounds.pop();
    }
    player.boxGrounds[i] = (y == this.y && rectCircle(this.x-0.1,this.y-0.1,this.w+0.1,this.h+0.1,player.x,player.y,player.dia,player.dia));

    if(rectCircle(this.x-0.1,this.y-0.1,this.w+0.1,this.h+0.1,player.x,player.y,player.dia,player.dia)){
      if(this.function == "changePoint"){
        respawn.changePoint(this.x+this.w/2,this.y-player.rad);
        respawn.box = this;
      }
      if(y == this.y){
        player.boxGrounds[i] = "bottom";
        //Friction
        if(this.settings.move){
          let dif = player.x-this.x;
          player.x = this.x + dif + this.speed * ((this.point | 0)*2-1);
        }
      }
      else if(y == this.y + this.h){
        player.boxGrounds[i] = "top";
      }
      else if(x == this.x){
        player.boxGrounds[i] = "right";
      }
      else if(x == this.x + this.w){
        player.boxGrounds[i] = "left";
      }
    }

    if(dist(x,y,player.x,player.y) <= player.dia/2 && !collidePointRect(player.x,player.y,this.x,this.y,this.w,this.h)){
      while(dist(x,y,player.x,player.y) <= player.dia/2){
        let changeX = round(cos(theta) * 100) / 100;
        let changeY = round(sin(theta) * 100) / 100;
        player.x += changeY/10;
        player.y -= changeX/10;
      }
    }
  }
}

class Words{
  constructor(text,x,y,color){
    this.x = x;
    this.y = y;
    this.text = text;
    if(color){
      this.color = color;
    }
    else{
      this.color = "black";
    }
  }
  show(){
    text(this.text,this.x+(width/2-camera.x),this.y+(height/2-camera.y));
  }
}

class Player{
  constructor(){
    this.x = respawn.x;
    this.y = respawn.y;
    this.dia = 30;
    this.rad = this.dia/2;
    this.vel = new p5.Vector(0,0);
    this.acc = 0.05;
    this.touchGround = false;
    this.jumpStop = false;
    this.jumpReset = false;
    this.boxGrounds = [];
    this.jumpAmount = 0;
    this.touchWall = false;
    this.changeBack = false;
    this.grav = true;
    this.dead = false;
    //Changables
    this.jumpForce = 8;
    this.maxSpeed = 6;
    this.jumpTimes = 2;
    this.gravWay = false;
    this.changables = [false,false,false,false];
    this.maxTime = [10,15,10,15];
    this.changeTime = [10,15,10,15];
  }
  show(){
    fill(170, 62, 152);
    noStroke();
    ellipse(this.x+(width/2-camera.x),this.y+(height/2-camera.y),this.dia,this.dia);
    fill(68, 100, 173);
    arc(width/2,height/2,this.dia,this.dia,0,TWO_PI*(this.jumpAmount/this.jumpTimes),PIE);
  }
  move(){
    if(flyMode){
      if(keys[Keys.left]){
        this.x -= 5;
      }
      if(keys[Keys.right]){
        this.x += 5;
      }
      if(keys[Keys.up]){
        this.y -= 5;
      }
      if(keys[Keys.down]){
        this.y += 5;
      }
      this.grav = false;
    }
    else{
      this.grav = true;
      if(keys[Keys.left]){
        this.x -= this.vel.x;
        if(this.vel.x < this.maxSpeed){
          this.vel.x += this.acc;
        }
      }
      if(keys[Keys.right]){
        this.x += this.vel.x;
        if(this.vel.x < this.maxSpeed){
          this.vel.x += this.acc;
        }
      }
      if(this.y > 900){
        this.dead = true;
        this.deadType = "black";
      }
    }
  }

  physics(){
    if(this.changeBack){
      this.canJump = false;
      if(!this.touchWall){
        this.changeBack = false;
      }
    }
    if(!this.canJump){
      this.jumpReset = true;
    }
    if(this.touchGround){
      this.canJump = true;
    }
    if(!this.touchWall && this.jumpAmount <= this.jumpTimes){
      this.canJump = true;
    }
    if(!this.touchGround){
      if(this.vel.y < 10 && this.grav){
        this.vel.y += grav;
      }
    }
    else if(!keys[Keys.up] && this.touchGround){
      //Gets called when first touching ground
      this.vel.y = 0;
      this.jumpReset = true;
      this.jumpAmount = 0;
    }
    if(this.grav){
      this.y += this.vel.y * ((this.gravWay | 0) * 2 - 1) * -1;
    }
    if(this.jumpStop){
      this.vel.y /= 2;
      this.jumpStop = false;
    }
  }
  collide(){
    for(let i = 0; i < area.length; i++){
      let num = area[i];
      boxes[num].move();
      boxes[num].show();
      boxes[num].collide(i);
    }
    this.touchGround = false;
    if(this.boxGrounds.includes("bottom")){
      this.touchGround = true;
    }
    if(this.boxGrounds.includes("top")){
      this.jumpStop = true;
    }
    if(this.boxGrounds.includes("left") || this.boxGrounds.includes("right")){
      if(!this.canJump && !this.changeBack){
        this.canJump = true;
      }
      this.touchWall = true;
    }
    else{
      this.touchWall = false;
      if(!this.touchGround && this.jumpAmount >= this.jumpTimes){
        this.canJump = false;
      }
    }
  }
  obsticles(){
    for(let i = 0; i < obArea.length; i++){
      let ob = obsticles[obArea[i]];
      ob.move();
      ob.show();
      ob.collide();
    }
  }
  die(){
    if(this.dead){
      this.dia *= 0.85;
      this.rad = this.dia/2;
      let i = getInd(changeCols,this.deadType);
      if(i !== 3){
        this.changables[i] = true;
      }
      this.vel.y = 0;
    }
    if(this.dia < 2){
      this.dead = false;
      for(let i = 0; i < this.changeTime.length; i++){
        this.changeTime[i] = this.maxTime[i];
      }

      this.dia = 30
      this.x = respawn.x;
      this.y = respawn.y;
      this.jumpAmount = 0;
    }
    if(this.deadType == "black" && player.x > 10000){
      console.log(12312341);
      this.changables[3] = true;
    }
  }
}

class Camera{
  constructor(){
    this.x = 0;
    this.y = 0;
    this.scale = 1;
  }
  move(){
    this.x = player.x;
    this.y = player.y;
  }
}

let img;
function preload(){
  img = loadImage('https://benazoid.com/images/block.png');
}
function setup(){
  createCanvas(700,500);
}

boxes = [
  new Box(-4000,400,4400,50,{move:false}),
  new Box(-100,399,50,50,{function:"changePoint"}),
  new Box(2000,400,500,50,{move:false}),
  new Box(2285,399,50,50,{function:"changePoint"}),
  new Box(2550,-300,50,500,{move:false}),
  new Box(2750,-300,50,700,{move:false}),
  new Box(2750,-300,500,50,{move:false}),
  new Box(3217,-800,1500,50,{move:false}),
  new Box(3417,-800,50,50,{function:"changePoint"}),
  new Box(3600,-1700,50,700,{move:false}),
  new Box(3600,-1700,700,50,{move:false}),
];
obsticles = [
  new Enemy(10,300,20,20,{move:true,x2:300,y2:300,speed:1,color:"green"}),
  new Enemy(2312,0,20,20,{move:false,color:"blue"}),
];
words = [
  new Words("Hi there how are you",100,250),
  new Words("green squares kill you, but give you four jumps instead of two",2000,250),
  new Words("try getting over this gap",540,270),
  new Words("try some wall jumping now",2500,250),
  new Words("this ledge is pretty high up",3217,-700),
  new Words("noice\n\n\n                      blue squares give you a jump boost",3413,-1000),
];

respawn = new Respawn();
respawn.x = checks[curCheck].x + checks[curCheck].w/2;
respawn.y = checks[curCheck].y - checks[curCheck].h/2;
player = new Player();

let changeNames = ["Jumps", "Speed", "Jump Force","Reverse Gravity"];
let changeCols = ["green","red","blue","black"]

camera = new Camera();

function draw(){
  background(235, 245, 240);
  noFill();
  stroke(0);
  rect(0,0,width,height);
  area = [];
  obArea = [];
  for(let i = 0; i < boxes.length; i++){
    let box = boxes[i];
    if(box.canMove){
      area.push(i);
    }
    else if(collideRectRect(box.x,box.y,box.w,box.h,player.x-width/2,player.y-height/2,width,height)){
      area.push(i);
    }
  }
  for(let i = 0; i < obsticles.length; i++){
    let ob = obsticles[i];
    if(collideRectRect(0,0,width,height,ob.box[0],ob.box[1],ob.box[2],ob.box[3])){
      obArea.push(i);
    }
    else if(collideRectRect(camera.x-width/2,camera.y-height/2,width,height,ob.x,ob.y,ob.w,ob.h)){
      obArea.push(i);
    }

    //Cheat codes
    if(pressedKeys.length >= flyKeys.length){
      for(let i = 0; i < pressedKeys.length-flyKeys.length+1; i++){
        let amt = 0;
        for(let j = 0; j < flyKeys.length; j++){
          if(pressedKeys[i + j] == flyKeys[j]){
            amt++;
          }
        }
        if(amt == flyKeys.length){
          if(flyMode){
            flyMode = false;
            console.log("fly mode disabled");
          }
          else{
            flyMode = true;
            console.log("fly mode enabled");
          }
          pressedKeys = [];
        }
      }
    }
  }


  //Class functions


  player.move();
  player.physics();
  player.collide();
  player.obsticles();
  camera.move();
  player.show();
  player.die();
  respawn.update();

  for(word of words){
    word.show();
  }

  //Displaying Changables

  let amt = 0;
  for(let i = 0; i < player.changables.length; i++){
    let change = player.changables[i];
    if(change){
      let amt = player.changeTime[i]/player.maxTime[i];
      fill(0);
      text(changeNames[i],i*100 + 10,20)
      fill(changeCols[i]);
      arc(i * 100 + 43,40,20,20,0,TWO_PI*(amt),PIE);
      player.changeTime[i] -= (1/60);
      if(player.changeTime[i] < 0){
        player.changables[i] = false;
        player.changeTime[i] = player.maxTime[i];
        console.log(i);
      }
      //player.jumpTimes = 2;
      player.maxSpeed = 6;
      player.jumpForce = 8;
      //Make with math???
      player.jumpTimes = 2 + ((player.changables[0] | 0) * 2);
      if(player.x > 10000){
        player.gravWay = player.changables[3];
      }
      if(player.changables[i]){
        switch(i){
          case 0:
            player.jumpTimes = 4;
            break;
          case 1:
            player.maxSpeed = 15;
            break;
          case 2:
            player.jumpForce = 15;
        }
      }
    }
  }
}
